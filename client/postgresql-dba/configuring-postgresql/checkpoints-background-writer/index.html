<div data-github-url="https://github.com/kamranahmedse/developer-roadmap/tree/master/src/data/roadmaps/postgresql-dba/content/105-configuring-postgresql/105-checkpoints-background-writer.md"></div> <h1 id="checkpoints-and-background-writer">Checkpoints and Background Writer</h1>
<p>In this section, we will discuss two important components of PostgreSQL’s performance: <strong>checkpoints</strong> and the <strong>background writer</strong>.</p>
<h2 id="checkpoints">Checkpoints</h2>
<p>A <em>checkpoint</em> is a point in time when PostgreSQL ensures that all the modified data in the shared buffers is written to the data files on the disk. Checkpoints are vital for maintaining data integrity and consistency, as they help reduce data loss in case of a crash.</p>
<p>There are two main ways a checkpoint can be triggered:</p>
<ul>
<li>
<p><strong>Time-based checkpoints:</strong> These checkpoints are triggered automatically by the PostgreSQL server based on the <code>checkpoint_timeout</code> parameter in the <code>postgresql.conf</code> file. By default, this value is set to 5 minutes.</p>
</li>
<li>
<p><strong>Transaction-based checkpoints:</strong> These checkpoints are triggered when the number of transaction log (WAL) files since the last checkpoint exceeds the value defined by the <code>max_wal_size</code> parameter.</p>
</li>
</ul>
<p>You can adjust these parameters to control the frequency of checkpoints triggered by the server:</p>
<ul>
<li>
<p><code>checkpoint_timeout</code>: The length of time (in seconds) between automatic checkpoints. Increasing this value may reduce the overall checkpoint frequency, potentially improving the performance of the system at the cost of potentially increasing recovery time in case of a crash.</p>
</li>
<li>
<p><code>max_wal_size</code>: The maximum amount of WAL data (in MB) to be stored before a checkpoint is triggered. Increasing this value means that checkpoints may happen less frequently. However, larger values can also result in increased recovery time.</p>
</li>
</ul>
<h2 id="background-writer">Background Writer</h2>
<p>PostgreSQL uses a shared buffer cache to store frequently accessed data in memory, improving the overall performance of the system. Over time, these shared buffers can become “dirty,” meaning they contain modified data that has not yet been written back to the disk. To maintain data consistency and reduce the impact of checkpoints, PostgreSQL utilizes a process called <em>background writer</em> to incrementally write dirty buffers to disk.</p>
<p>The background writer is governed by several configuration parameters:</p>
<ul>
<li>
<p><code>bgwriter_lru_multiplier</code>: This parameter controls how aggressive the background writer is in writing dirty buffers. A higher value means a more aggressive background writer, effectively reducing the number of dirty buffers and lessening the impact of checkpoints.</p>
</li>
<li>
<p><code>bgwriter_lru_maxpages</code>: The maximum number of dirty buffers the background writer can process during each round of cleaning.</p>
</li>
<li>
<p><code>bgwriter_flush_after</code>: The number of buffers written by the background writer after which an operating system flush should be requested. This helps to spread out the disk write operations, reducing latency.</p>
</li>
</ul>
<p>By tuning these parameters, you can optimize the performance of the background writer to minimize the impact of checkpoints on your system’s performance. However, it is important to note that overly aggressive background writer settings can lead to increased I/O activity, potentially affecting overall system performance.</p>
<p>In summary, understanding and optimizing checkpoints and the background writer in PostgreSQL is crucial to maintaining data consistency while achieving the best possible performance. Carefully consider your system’s workload and adjust these parameters accordingly to find the right balance between data integrity and performance.</p>