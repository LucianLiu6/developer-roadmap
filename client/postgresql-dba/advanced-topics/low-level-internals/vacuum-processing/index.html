<div data-github-url="https://github.com/kamranahmedse/developer-roadmap/tree/master/src/data/roadmaps/postgresql-dba/content/110-advanced-topics/100-low-level-internals/101-vacuum-processing.md"></div> <h1 id="vacuum-processing">Vacuum Processing</h1>
<p>Vacuum processing is an essential aspect of maintaining the performance and stability of a PostgreSQL database. PostgreSQL uses a storage technique called Multi-Version Concurrency Control (MVCC), which allows multiple transactions to access different versions of a database object simultaneously. This results in the creation of multiple “dead” rows whenever a row is updated or deleted. Vacuum processing helps in cleaning up these dead rows and reclaiming storage space, preventing the database from becoming bloated and inefficient.</p>
<h2 id="types-of-vacuum-processing">Types of Vacuum Processing</h2>
<ul>
<li><strong>Manual Vacuum</strong>: Initiated by the user, a manual vacuum can be performed using the <code>VACUUM</code> SQL command. It scans the tables and indexes and removes dead rows where appropriate.</li>
</ul>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0" data-language="sql"><code><span class="line"><span style="color:#F8F8F2">VACUUM table_name;</span></span>
<span class="line"></span></code></pre>
<ul>
<li><strong>Automatic Vacuum</strong>: To automate the vacuuming process, PostgreSQL implements the <em>autovacuum daemon</em>. This background process starts upon initiating a PostgreSQL instance and operates on the entire cluster. It monitors and analyzes the database for bloated tables and reclaims storage space according to predefined settings in the <code>postgresql.conf</code> configuration file.</li>
</ul>
<h2 id="vacuum-processing-options">Vacuum Processing Options</h2>
<ul>
<li><strong>Vacuum</strong>: The basic vacuum process removes dead rows and optimizes the free space in the database. However, it doesn’t reclaim storage space or optimize the indexes for the underlying file system.</li>
</ul>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0" data-language="sql"><code><span class="line"><span style="color:#F8F8F2">VACUUM table_name;</span></span>
<span class="line"></span></code></pre>
<ul>
<li><strong>Vacuum Full</strong>: The <code>VACUUM FULL</code> command not only removes dead rows but also compacts the table and its indexes, reclaiming storage space for the file system. Be cautious with this command, as it might lock the table for a long time during the operation.</li>
</ul>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0" data-language="sql"><code><span class="line"><span style="color:#F8F8F2">VACUUM FULL table_name;</span></span>
<span class="line"></span></code></pre>
<ul>
<li><strong>Analyze</strong>: The <code>ANALYZE</code> command updates the statistics about the distribution of the key values in the tables and indexes. These statistics help the PostgreSQL query planner to choose the most efficient execution plan for the queries.</li>
</ul>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0" data-language="sql"><code><span class="line"><span style="color:#F8F8F2">ANALYZE table_name;</span></span>
<span class="line"></span></code></pre>
<ul>
<li><strong>Vacuum Analyze</strong>: Combining both <code>VACUUM</code> and <code>ANALYZE</code>, this command is useful when you want to perform vacuum processing and update the statistics simultaneously.</li>
</ul>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0" data-language="sql"><code><span class="line"><span style="color:#F8F8F2">VACUUM ANALYZE table_name;</span></span>
<span class="line"></span></code></pre>
<ul>
<li><strong>Vacuum Freeze</strong>: The <code>VACUUM FREEZE</code> command is primarily used for tables with a high update frequency. It marks all rows as “frozen,” which means the transaction information is no longer needed for MVCC, reducing the need for subsequent vacuum processing.</li>
</ul>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto;" tabindex="0" data-language="sql"><code><span class="line"><span style="color:#F8F8F2">VACUUM FREEZE table_name;</span></span>
<span class="line"></span></code></pre>
<h2 id="customizing-vacuum-processing">Customizing Vacuum Processing</h2>
<p>Vacuum processing behavior can be adjusted by modifying the following configuration parameters in the <code>postgresql.conf</code> file:</p>
<ul>
<li><code>autovacuum_vacuum_scale_factor</code>: Controls the fraction of the table size to be reclaimed.</li>
<li><code>autovacuum_analyze_scale_factor</code>: Controls the fraction of the table size to trigger an <code>ANALYZE</code>.</li>
<li><code>vacuum_cost_limit</code>: Determines the maximum cost to be spent on vacuuming before a batch is terminated.</li>
<li><code>autovacuum_vacuum_cost_limit</code>: Determines the maximum cost to be spent on vacuuming when done by the autovacuum daemon.</li>
</ul>
<p>In conclusion, vacuum processing is vital for keeping a PostgreSQL database healthy and performant. Understanding and regularly using vacuum processes ensures that your database remains efficient and maintainable.</p>