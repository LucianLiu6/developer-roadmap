<div data-github-url="https://github.com/kamranahmedse/developer-roadmap/tree/master/src/data/roadmaps/system-design/content/116-performance-antipatterns/109-synchronous-io.md"></div> <h1 id="synchronous-io">Synchronous I/O</h1>
<p>Blocking the calling thread while I/O completes can reduce performance and affect vertical scalability.</p>
<p>A synchronous I/O operation blocks the calling thread while the I/O completes. The calling thread enters a wait state and is unable to perform useful work during this interval, wasting processing resources.</p>
<p>Common examples of I/O include:</p>
<ul>
<li>Retrieving or persisting data to a database or any type of persistent storage.</li>
<li>Sending a request to a web service.</li>
<li>Posting a message or retrieving a message from a queue.</li>
<li>Writing to or reading from a local file.</li>
</ul>
<p>This antipattern typically occurs because:</p>
<ul>
<li>
<p>It appears to be the most intuitive way to perform an operation.</p>
</li>
<li>
<p>The application requires a response from a request.</p>
</li>
<li>
<p>The application uses a library that only provides synchronous methods for I/O.</p>
</li>
<li>
<p>An external library performs synchronous I/O operations internally. A single synchronous I/O call can block an entire call chain.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/azure/architecture/antipatterns/synchronous-io/" rel="noopener noreferrer nofollow" target="_blank">@article@What is Synchronous I/O antipattern?</a></p>
</li>
</ul>